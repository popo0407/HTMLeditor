### 2\. システムアーキテクチャと技術選定の提案

#### ① システム全体のアーキテクチャ： **階層型アーキテクチャ (3-Tier Architecture)**

本システムには、責務が明確に分離された階層型アーキテクチャが最適です。マイクロサービスは現状の要件に対して過剰であり、開発・運用の複雑性を不必要に増大させる可能性があります。

  * **プレゼンテーション層 (Frontend)**: ユーザーインターフェースの構築とインタラクションを担当します。今回の要件であるリッチなブロックエディタの責務はすべてこの層が担います。
  * **アプリケーション層 (Backend)**: ビジネスロジックとデータアクセスを担当します。メール送信やアドレス帳管理といったサーバーサイドの処理に特化します。
  * **データ層 (Database)**: アドレス帳データを永続化します。

<!-- end list -->

```
        ユーザー
          ↓↑  (HTTPS)
┌──────────────────────┐
│  プレゼンテーション層 (Frontend) │
│  (React / IIS上で静的配信)     │
│  ・UI/UX (ブロックエディタ)    │
│  ・状態管理                  │
│  ・ブラウザAPI連携 (Clipboard) │
└─────────┬──────────┘
          ↓↑  (HTTP API Call)
┌──────────────────────┐
│  アプリケーション層 (Backend)  │
│  (Python: FastAPI / IIS)       │
│ ・APIエンドポイント (Routes)   │
│ ・ビジネスロジック (Services)  │
│ ・データアクセス (Repositories)│
└─────────┬──────────┘
          ↓↑  (DB Connection)
┌──────────────────────┐
│        データ層 (Database)     │
│        (SQLite / etc.)         │
│     ・アドレス帳データ         │
└──────────────────────┘
```

**【選定理由】**

  * **関心の分離 (SoC)**: 貴社の開発方針「II. 関心の分離 (SoC) を意識せよ」に完全に合致し、フロントエンドとバックエンドの開発を並行して進めやすくなります。
  * **高い保守性**: 各層が独立しているため、UIの変更がビジネスロジックに影響を与えず、また逆も然りです。将来の機能追加も影響範囲を特定しやすくなります。
  * **スキルセットへの適合**: 貴社開発チームのPython/JavaScriptというスキルセットを最大限に活かせます。

#### ② API層（バックエンド）の技術選定： **FastAPI**

貴社に豊富な経験がある **FastAPI** の採用を強く推奨します。

| フレームワーク | メリット（本システムにおいて） | デメリット（本システムにおいて） |
| :--- | :--- | :--- |
| **FastAPI (推奨)** | ・**経験の活用**: 学習コストがゼロで即座に開発に着手可能。\<br\>・**DI機能**: 開発方針「III. 依存性注入 (DI) を徹底せよ」と完全に一致。\<br\>・**パフォーマンス**: 非同期処理による高速なレスポンス。\<br\>・**生産性**: Pydanticによる型ヒントとバリデーション、自動APIドキュメント生成が開発を加速。 | ・特になし。現状の要件とスキルセットに対して最適。 |
| Flask | ・シンプルで軽量。 | ・DIや非同期、データ検証は追加ライブラリが必要となり、FastAPIほどの統合された開発体験は得られない。 |
| Django | ・フルスタックで多機能。 | ・本システムの要件（シンプルなAPIとアドレス帳管理のみ）に対して明らかにオーバースペック。設定が複雑になりがち。 |

#### ③ サービス層（ビジネスロジック）の設計： **サービスレイヤパターン**

ビジネスロジックの実装には、**サービスレイヤパターン**の採用が適しています。これは、ユースケースごとにサービスクラスを作成する設計です。

  * **例**: `AddressBookService`, `MailService`
  * **AddressBookService**: 共通IDの検証、アドレス帳の取得・作成、連絡先の追加といった責務を持つ。
  * **MailService**: 編集内容からHTMLファイルを生成し、`AddressBookService`から取得した宛先リストを元にメールを送信する責務を持つ。

**【選定理由】**

  * **単一責任の原則 (SRP)**: 開発方針「I. 単一責任の原則 (SRP) を徹底せよ」の通り、各サービスが明確な責務を持つことで、コードの可読性と保守性が向上します。
  * **テスト容易性**: サービス単位でロジックが完結しているため、ユニットテストが非常に書きやすくなります。DIと組み合わせることで、依存するリポジトリ層をモックに差し替えてテストできます。
  * **拡張性**: 新しいビジネス要件が追加された場合、新しいサービスクラスを追加するか、既存のサービスにメソッドを追加することで対応でき、影響範囲を最小限に抑えられます。

#### ④ データアクセス層の技術選定： **SQLAlchemy (ORM)**

データベースとの連携には、Pythonのデファクトスタンダードである **SQLAlchemy** のようなORM（Object-Relational Mapper）の利用を推奨します。

| 方法 | メリット | デメリット |
| :--- | :--- | :--- |
| **SQLAlchemy (推奨)** | ・**DB非依存**: SQLiteから将来的にPostgreSQL等へ移行する際もコード修正が最小限。\<br\>・**生産性と安全性**: Pythonオブジェクトとしてデータを扱え、SQLインジェクションのリスクを低減。\<br\>・**保守性**: Repositoryパターンとの親和性が高く、データアクセスロジックをカプセル化しやすい。 | ・「外部ライブラリ」に該当する可能性。しかし、データアクセスのための標準的なツールであり、自前実装のリスクとコストを考えると導入価値は絶大。 |
| 直接DBコネクタ (例: `sqlite3`) | ・標準ライブラリのみで完結。 | ・生SQLの記述が必要で、ミスが発生しやすい。\<br\>・DB製品にコードが依存する。\<br\>・保守性が低下しがち。 |

**【ご提案】**
「外部ライブラリをなるべく使用したくない」という方針は尊重します。しかし、SQLAlchemyは車輪の再発明を避け、開発の生産性とコードの堅牢性を飛躍的に向上させるための投資と捉えることができます。導入を強くお勧めします。

#### ⑤ フロントエンドの設計： **React**

ご提案の通り、**React** は本システムのフロントエンド開発に最適です。

**【選定理由】**

  * **コンポーネントベース**: 開発方針「II. コンポーネントベースでUIを構築せよ」に完全に合致。ブロックエディタの各ブロック、サイドバー、モーダルなどを再利用可能な部品として効率的に開発できます。
  * **宣言的UI**: 複雑なUIの状態（どのブロックが選択されているか、など）の管理が容易になり、コードの見通しが良くなります。
  * **エコシステム**: 状態管理（Context APIやZustandなど）、ルーティング、テストなど、堅牢なアプリケーションを構築するためのツールが揃っています。（ライブラリ選定は慎重に行う必要があります）

**【他の選択肢について】**
素のJavaScript (Vanilla JS)での実装は、ブロックエディタのような複雑な状態管理とDOM操作が絡む要件では、コードがスパゲッティ化しやすく保守性が著しく低下するため、推奨しません。Reactのようなフレームワークが提供する「骨格」を利用することが、結果的に品質と生産性の向上に繋がります。

#### ⑥ その他のおすすめ技術と注意点

  * **クリップボード連携**: HTML標準の **Navigator Clipboard API** (`navigator.clipboard.readText()`, `navigator.clipboard.read()`, `navigator.clipboard.writeText()`) を使用します。これにより、ライブラリ不要でテキストと画像のコピー＆ペーストに対応できます。ユーザーへのアクセス許可ダイアログが表示される点も要件と一致します。
  * **ブロックエディタの再編集可能なHTML (F-001-5)**: 出力するHTMLの各要素に、`data-block-type="heading"` のようなカスタムデータ属性を埋め込みます。再読み込み時には、この属性をキーにしてDOMを解析し、Reactのコンポーネント状態（JSONデータ）に復元します。
  * **PDF出力 (F-003-2)**: 外部ライブラリを避ける最も現実的な方法は、**ブラウザの印刷機能を活用する**ことです。「PDFとしてダウンロード」ボタンがクリックされたら、`window.print()` を実行し、ユーザーにOSの印刷ダイアログから「PDFとして保存」を選択してもらうようUIで案内します。印刷時専用のCSSを用意することで、レイアウトを最適化できます。
  * **IISでのFastAPIホスティング**: `wfastcgi` または `httpPlatformHandler` を用いてIIS上でFastAPIアプリケーションを動作させます。初期設定に若干の調査が必要になる可能性があります。

-----

### 3\. 各機能の詳細な実装方針

以下に、各機能要件を実現するための具体的な実装方針を記述します。

#### **F-001: コンテンツ編集機能 & F-002: 画像取り込み機能**

  * **担当**: フロントエンド (React)
  * **データ構造**: 編集中のコンテンツは、コンポーネントのstateとしてJSON配列で管理します。
    ```json
    [
      { "id": "uuid-1", "type": "heading1", "content": "議事録" },
      { "id": "uuid-2", "type": "paragraph", "content": "これはサンプルテキストです。" },
      { "id": "uuid-3", "type": "image", "src": "data:image/png;base64,..." }
    ]
    ```
  * **実装方針**:
      * **(F-001-1)** サイドバーのボタンクリックで `navigator.clipboard.readText()` を実行。取得したHTML文字列を `DOMParser` で解析し、`data-block-type` 属性を元に上記のJSON構造へ変換してstateを更新します。
      * **(F-001-2)** 「＋」ボタンクリックで、挿入したいブロック種別を選択するUIを表示。選択後、指定の位置のstate配列に新しいブロックオブジェクトを挿入します。
      * **(F-001-3)** ブロックオブジェクトに `style: "important"` のようなプロパティを追加・削除し、それに応じてCSSクラスを動的に適用します。
      * **(F-001-4, F-001-6)** stateの配列を `map` でループして各ブロックコンポーネントを描画。各コンポーネントは、自身のIDをキーにstateを更新する関数（テキスト変更、削除）をpropsとして受け取ります。
      * **(F-001-7)** **HTML Drag and Drop API** を利用。`ondragstart`で移動対象のブロックIDを保持し、`ondrop`でドロップ先の位置を特定。state配列の順序を入れ替えて再描画します。
      * **(F-002-1, F-002-2)** 画像は `FileReader` API を使って **Base64** 文字列に変換し、stateの`src`にセットします。これにより、画像データをHTML内に埋め込むことができ、単一ファイルとして扱えます。クリップボードからの画像は `navigator.clipboard.read()` で取得します。

#### **F-003: 保存・出力機能**

  * **担当**: フロントエンド (React)
  * **実装方針**:
      * **(F-003-1)** 現在のstate (JSON配列) から最終的なHTML文字列を生成します。この際、再編集のために `data-block-type` 属性を必ず含めます。生成したHTMLを `Blob` オブジェクトにし、`<a>` タグのダウンロード機能を使ってファイルとして保存させます。
      * **(F-003-2)** 上記「⑥その他」で提案した通り、`window.print()` を利用します。印刷専用CSS (`@media print`) で、ヘッダーやサイドバーなどを非表示にし、プレビューエリアのみが印刷されるように調整します。
      * **(F-003-3)** プレビュー表示用のHTML文字列を生成し、`navigator.clipboard.writeText()` でクリップボードにコピーします。（リッチテキストをコピーするには `ClipboardItem` オブジェクトを使う高度な実装が必要です）

#### **F-004: アクセス制限機能 & F-006: アドレス帳機能**

  * **担当**: バックエンド (FastAPI), フロントエンド (React)
  * **APIエンドポイント (FastAPI)**:
      * `POST /api/address-books`: 共通IDを検証し、存在すればアドレス帳を返す。存在しなければ新規作成するか確認後、作成して返す。
      * `POST /api/address-books/{common_id}/contacts`: 指定したアドレス帳に新しい連絡先を追加する。
  * **実装方針 (バックエンド)**:
      * **(F-004-1, F-004-2)** `AddressBookService` がロジックを担当。Repository層を通じてDBを検索し、IDの存在チェックと新規作成処理を行います。
      * **(F-006-1, F-006-2)** DBスキーマは `CommonIDs` テーブルと `Contacts` テーブル（`common_id` を外部キーに持つ）で構成します。SQLAlchemyのモデルとして定義し、Repository層がCRUD操作を実装します。
  * **実装方針 (フロントエンド)**:
      * 共通ID入力モーダルやメール作成画面（宛先リスト表示、連絡先追加フォーム）をReactコンポーネントとして作成し、上記のAPIを呼び出してデータを取得・更新します。

#### **F-005: メール送信機能**

  * **担当**: バックエンド (FastAPI), フロントエンド (React)
  * **APIエンドポイント (FastAPI)**:
      * `POST /api/send-mail`: メール送信リクエストを受け付ける。リクエストボディには共通ID、宛先メールアドレスのリスト、HTMLコンテンツを含める。
  * **実装方針 (バックエンド)**:
      * `MailService` がロジックを担当。
      * 1.  リクエストから受け取ったHTMLコンテンツを一時ファイルとして保存。
      * 2.  Python標準ライブラリの `smtplib` と `email` モジュールを使用し、メールを作成。
      * 3.  件名・本文は固定文字列をセット (F-005-4)。差出人アドレスも設定 (F-005-2)。
      * 4.  `MIMEMultipart` を使い、HTMLファイルを添付ファイルとして追加 (F-005-5)。
      * 5.  設定されたSMTPサーバー経由でメールを送信します。
  * **実装方針 (フロントエンド)**:
      * メール作成画面で「送信」ボタンが押されたら、現在の編集内容（HTML文字列）と選択された宛先リストをペイロードとして、上記のAPIを呼び出します。
